#' Upload a directory to the gypsum backend
#'
#' Upload a directory containing one or more datasets to the gypsum backend as a versioned asset.
#' This requires uploader permissions to the \pkg{scRNAseq} project.
#' 
#' @param path String containing the path to a directory.
#' This can either be the same directory generated by \code{\link{saveDataset}}
#' or it can be a parent directory containing multiple subdirectories generated by \code{\link{saveDataset}}.
#' @param name String containing the name of the asset. 
#' This should not contain \code{/} or start with \code{..}.
#' @param version String containing the version of the asset. 
#' This should not contain \code{/} or start with \code{..}.
#' @param package String containing the package name.
#' @param url String containing the URL to the gypsum REST API.
#' @param concurrent Integer scalar specifying the number of concurrent uploads.
#' @param abort.failed Logical scalar indicating whether to abort the upload on any failure.
#' Setting this to \code{FALSE} can be helpful for diagnosing upload problems.
#'
#' @return On successful upload, \code{NULL} is invisibly returned.
#'
#' @author Aaron Lun
#' @examples
#' example(saveDataset, verbose=FALSE)
#' if (interactive()) {
#'     uploadDirectory(tmp)
#' }
#'
#' @export
uploadDirectory <- function(path, name, version, package="scRNAseq", url=NULL, concurrent=1, abort.failed=TRUE) {
    if (is.null(url)) {
        url <- gypsum::restUrl()
    }

    # Going through all files and unpacking the explicit links.
    all.files <- list_files(path)

    blob <- gypsum::startUpload(
        project=package,
        asset=name,
        version=version, 
        files=all.files,
        directory=tmp,
        url=url
    )
    if (abort.failed) {
        on.exit(gypsum::abortUpload(blob))
    }

    gypsum::uploadFiles(blob, directory=tmp, url=url, concurrent=concurrent)
    gypsum::completeUpload(blob, url=url)
    invisible(NULL)
}

list_files <- function(full, relative="", link=NULL) {
    # Handle ScrnaseqMatrix objects.
    collected <- list.files(full)
    if (".link" %in% collected) {
        link <- jsonlite::fromJSON(file.path(full, ".link"), simplifyVector=FALSE)
        collected <- setdiff(collected, '.link')
    }

    all.files <- as.list(collected)
    for (f in collected) {
        f2 <- file.path(full, f)
        r2 <- if (relative == "") f else paste0(relative, "/", f)
        stuff <- file.info(f2)

        if (stuff$isdir) {
            link2 <- link
            if (!is.null(link2)) {
                link2$path <- paste0(link2$path, "/", f)
            }
            all.files[[f]] <- list_files(f2, r2, link=link2)
        } else if (is.null(link)) {
            all.files[[f]] <- list(list(path=r2, type="dedup", md5sum=digest::digest(file=f2), size=stuff$size))
        } else {
            all.files[[f]] <- list(list(path=r2, type="link", link=list(project=link$project, asset=link$asset, version=link$version, path=paste0(link$path, f))))
        }
    }

    unlist(all.files, recursive=FALSE)
}
