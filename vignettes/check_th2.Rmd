---
title: "Check TH2 data"
author: "Davide Risso"
date: "April 26, 2016"
output: html_document
bibliography: biblio.bib
---

We downloaded the data from [@mahata2014single] (ArrayExpress: E-MTAB-2512).
This consists of 96 single-cell RNA-seq samples.

The metadata of the ArrayExpress Accession (downloaded from 
http://www.ebi.ac.uk/arrayexpress/files/E-MTAB-2512/E-MTAB-2512.sdrf.txt) 
indicate that there are two cells of low quality (noted as "low read count") and
three cells for which dublets have been captured in the Fluidigm platform (noted
as "multiple cells"). This is in agreement with [@mahata2014single] and
[@brennecke2013accounting] that analyzed 91 cells.

```{r metadata}
system("wget http://www.ebi.ac.uk/arrayexpress/files/E-MTAB-2512/E-MTAB-2512.sdrf.txt")
metadata <- read.table("E-MTAB-2512.sdrf.txt", header=TRUE, sep='\t')
system("rm E-MTAB-2512.sdrf.txt")

as.character(unique(metadata[,1][which(metadata$Characteristics.single.cell.well.quality.=="multiple cells")]))
as.character(unique(metadata[,1][which(metadata$Comment.read.count.=="low read count")]))
```

The data were also analyzed by [@buettner2015computational]. In this paper the 
authors analyzed only 81 cells, because they removed "duplets and cells with low
yield or poor quality cDNA." The data used in [@buettner2015computational] can
be downloaded from the scLVM github repository
(https://github.com/PMBio/scLVM/blob/master/data/Tcell/data_Tcells.Rdata).

```{r rdata}
system("wget https://github.com/PMBio/scLVM/raw/master/data/Tcell/data_Tcells.Rdata")
load("data_Tcells.Rdata")
system("rm data_Tcells.Rdata")

dim(dataMouse)
colnames(dataMouse)
```

As expected the data consist of 81 cells. The colnames of the R object suggests that
the number after the underscore is the id of the cell. To make sure that this is
the case we can look at the correlation between the values of the Rdata object 
and our version of the data, obtained from the reanalysis of the data downloaded
from ArrayExpress.

To do this, we have to first map the ENSEMBL IDs with the gene symbols.

```{r our_data}
library(scRNAseq)
data(th2)

ens2sym <- read.table("../tmp/ens2symbols.txt", stringsAsFactors = FALSE)
ids <- ens2sym[,2]
names(ids) <- ens2sym[,1]
head(ids)

## only genes present in annotation
common <- intersect(rownames(th2), ids[rownames(dataMouse)])

## not 1to1 correspondence; take the first
common_sym <- ids[which(ids %in% common)]
sym <- tapply(common_sym, common_sym, function(x) x[1])
names(sym) <- tapply(names(common_sym), common_sym, function(x) x[1])
ens <- names(sym)

stopifnot(all(ens %in% rownames(dataMouse)))
stopifnot(all(sym %in% rownames(th2)))

## reduce to same genes
dataMouse <- dataMouse[ens,]
counts <- assay(th2)[sym,]
rownames(dataMouse) <- sym

stopifnot(all(!is.na(counts)))
stopifnot(all(!is.na(dataMouse)))

## reorder the cells
colnames(counts) <- sapply(strsplit(as.character(th2$id), "\ "), function(x) x[2])
counts <- counts[,order(as.numeric(colnames(counts)))]
```

We can now plot the correlation between the two matrices.

```{r plot_cor, fig.width=10, fig.height=10}
par(mfrow=c(2, 4))
for(j in 1:NCOL(counts)) {
  cors <- sapply(seq_len(NCOL(dataMouse)), function(i)
    cor(log1p(counts[,j]), log1p(dataMouse[,i])))
  plot(ecdf(cors), main=paste("Cell", j, ":", colnames(dataMouse)[which.max(cors)]))
}
par(mfrow=c(1, 1))
```

The title of each plot is the ID of our re-processed data matched with the ID
of the data from the github repository that has the highest correlation.

Note that for the 81 retained cells, we can perfectly match the IDs in the two
datasets.

This means that the cells that were filtered out by [@buettner2015computational]
are:

```{r filtered_out}
idx <- as.numeric(sapply(sapply(strsplit(colnames(dataMouse), "_"), function(x) strsplit(x[2], ".", fixed=TRUE)), function(x) x[1]))
print(which(!(1:96 %in% idx)))
```

These IDs do not match with the ones that are marked as dublets and low quality
in the ArrayExpressed metadata.

If we look at the number of reads and percentage of mapped reads

```{r plot_qc}
qc <- as.matrix(colData(th2)[,metadata(th2)$which_qc])

ids <- as.numeric(sapply(strsplit(as.character(colData(th2)$id), " "), function(x) x[2]))

plot(qc[,1], qc[,3], xlab="Total number of reads", ylab="Percentage of mapped reads")
points(qc[which(!(ids %in% idx)),c(1, 3)], pch=19, col=2) #filtered
points(qc[which(ids %in% c(74, 92, 93)),c(1, 3)], pch=19, col=4) #doublets
points(qc[which(ids %in% c(6, 7)),c(1, 3)], pch=19, col=6) #low reads
legend("bottomright", c("Filtered by Buettner", "Doublets", "Low reads"), fill=c(2, 4, 6))
```

## References
